import {
	argumentsQueue,
	callNodeType,
	IWEEK_GLOBAL_Object,
	TeacherId,
	TranspositionInstruction,
} from "../Interfaces/Interfaces";
import { PosType, TeacherType_nullValue } from "../types";
import { putHimAt } from "./Logic";
import { equals, util } from "./util";

function conflicts(
	...args:
		| [callNodeType]
		| [
				TranspositionInstruction[],
				{ pos: PosType; m: number; teacher: TeacherId }
		  ]
) {
	if (args.length === 1) {
		const vertex = args[0];
		if (
			vertex.week.allClasses[vertex.m].l[vertex.pos[0]][vertex.pos[1]]
				.isCemented
		)
			return true;

		for (let i = 0; i < vertex.pivots.length; i++) {
			if (
				equals(vertex.pivots[i].pos, vertex.pos) &&
				vertex.pivots[i].m === vertex.m
			) {
				return true;
			} else if (
				vertex.pivots[i].teacher === vertex.teacher &&
				equals(vertex.pivots[i].pos, vertex.pos)
			) {
				return true;
			}
		}
		let tmp: callNodeType | null;
		if (vertex.parent !== undefined) tmp = vertex.parent;
		else
			throw {
				...vertex,
				message: "Parent is undefined!",
				where: "in conflicts",
			};
		while (tmp !== null) {
			if (equals(tmp.pos, vertex.pos) && tmp.m === vertex.m) {
				return true;
			} else if (
				tmp.teacher === vertex.teacher &&
				equals(tmp.pos, vertex.pos)
			) {
				return true;
			}
			if (tmp.parent !== undefined) {
				tmp = tmp.parent;
			} else {
				throw {
					...tmp,
					message: "Parent is undefined!",
					where: "in conflicts",
				};
			}
		}
		return false;
	} else if (args.length === 2) {
		const base = args[0];
		const Step = args[1];
		for (let i = 0; i < base.length; i++) {
			if (equals(base[i].pos, Step.pos) && base[i].m === Step.m) {
				return true;
			} else if (
				base[i].teacher === Step.teacher &&
				equals(base[i].pos, Step.pos)
			) {
				return true;
			}
		}
		return false;
	} else return false;
}

function preStrictConflicts(vertex: callNodeType) {
	let tmp: callNodeType | null;
	if (
		vertex.week.allClasses[vertex.m].l[vertex.pos[0]][vertex.pos[1]]
			.isCemented
	) {
		return true;
	}
	if (vertex.parent !== undefined) tmp = vertex.parent;
	else throw { ...vertex, message: `Parent is undefined` };
	while (tmp !== null) {
		if (equals(tmp.pos, vertex.pos) && tmp.m === vertex.m) {
			return true;
		} else if (tmp.teacher === vertex.teacher) {
			return true;
		}
		if (tmp.parent !== undefined) tmp = tmp.parent;
	}
	return false;
}

const MAX_CALLS = 5;
// let queue: argumentsQueue = new argumentsQueue();

function enoughSolutions(
	week: IWEEK_GLOBAL_Object,
	justOne: boolean = false
): boolean {
	if (justOne) week.activateList.length > 1;
	return week.activateList.length > MAX_CALLS;
}
export function takeOneOffTheStack(
	vertex: callNodeType,
	queue: argumentsQueue
) {
	const debt = {
		...vertex.pivots[vertex.pivots.length - 1],
		parent: vertex,
		pivots: [...vertex.pivots],
	};
	debt.pivots.pop();
	queue.enqueue(debt);
}
/**
 * Schedule push calls in another Class to free up the vertex.pos in the vertex.m Class
 * @param vertex Dummy vertex used for The position [number,number] we need empty in next_m
 * @param AfterReChainNode This will be added to the call stack and will be executed after any vertex generated by this pivot call finds a solution
 */
function pivotTo(
	vertex: callNodeType,
	queue: argumentsQueue,
	visited: boolean[] = new Array(11).fill(false)
) {
	// should schedule the push calls to the queue
	if (vertex.pivotArgs === undefined) {
		throw { ...vertex, message: "call to pivotTo with missing pivotArgs" };
	} else if (!conflicts(vertex)) {
		const m = vertex.pivotArgs.next_m;
		if (visited[m] || visited[vertex.m]) {
			console.warn(`circular calls breaker used`);
			return;
		}
		visited[m] = true;
		visited[vertex.m] = true;
		const nextNode = vertex.pivotArgs.AfterReChainNode;
		const [X, Y] = vertex.pos;
		const augmentedParent = vertex.pivotArgs.beforeReChainNode;
		const NewStack =
			vertex.pivotArgs.beforeReChainNode === null
				? [...vertex.pivots]
				: [...vertex.pivotArgs.beforeReChainNode.pivots];
		if (nextNode !== undefined) NewStack.push(nextNode);
		// const teachers = util.removed(vertex.week.allClasses[m].l[X][Y].Options, vertex.week.allClasses[m].l[X][Y].currentTeacher);
		const replacementTeachers = vertex.week.allClasses[m].l[X][Y].Options;
		const requirePivoting = replacementTeachers.filter(
			(replacementTeacher: TeacherId) => {
				if (
					replacementTeacher ===
					vertex.week.allClasses[m].l[X][Y].currentTeacher
				)
					return false;
				const s = util.situation(
					replacementTeacher,
					vertex.pos,
					m,
					vertex.week
				);
				if (
					s.r === -1 ||
					(replacementTeacher ===
						vertex.week.allClasses[vertex.m].l[X][Y].currentTeacher &&
						s.r === vertex.m)
				) {
					queue.enqueue({
						callTo: "push",
						parent: augmentedParent,
						teacher: replacementTeacher,
						pos: vertex.pos,
						m,
						week: vertex.week,
						cycleClosingParentName: replacementTeacher,
						action: s.action,
						pivots: [...NewStack],
					});
					return false;
				} else if (s.r === vertex.m) {
					return false;
				} else return true;
			}
		);
		if (replacementTeachers.length - requirePivoting.length >= 3)
			// doesn't require pivoting .length >=2
			return;
		requirePivoting.forEach((replacementTeacher): void => {
			const s = util.situation(
				replacementTeacher,
				vertex.pos,
				m,
				vertex.week
			);
			pivotTo(
				{
					...vertex,
					pivots: [...NewStack], // if augmentedParent is null [] would have got to the next gen
					callTo: "pivotTo",
					pivotArgs: {
						next_m: s.r,
						AfterReChainNode: {
							callTo: "push",
							parent: undefined,
							teacher: replacementTeacher,
							pos: vertex.pos,
							m,
							week: vertex.week,
							cycleClosingParentName: replacementTeacher,
							action: s.action,
							pivots: [...NewStack],
						},
						beforeReChainNode: augmentedParent,
					},
				},
				queue,
				visited
			);
		});
	}
}
/**
 * back track and return the path to the root
 * @param vertex leaf
 */
export function backtrack(vertex: callNodeType): TranspositionInstruction[] {
	let tmp: callNodeType | null = vertex;
	const solution: TranspositionInstruction[] = [];
	while (tmp !== null) {
		solution.push({ teacher: tmp.teacher, pos: tmp.pos, m: tmp.m });
		if (tmp.parent === undefined) {
			throw { ...tmp, message: "parent undefined" };
		} else {
			tmp = tmp.parent;
		}
	}
	return solution;
}
/**
 *
 * @param vertex arguments for the pull call
 */
function pull(vertex: callNodeType, queue: argumentsQueue) {
	const { teacher, m, week } = vertex;
	const { activateList: solutions } = week;
	if (conflicts(vertex)) return;
	const edges: PosType[] =
		week.allClasses[m].teachers[teacher].periodsHere ||
		util.getHisActPeriods(week.allClasses[m], teacher);
	const q_lenBefore = queue.length();
	const localQueue = new argumentsQueue();
	edges.forEach((edge) => {
		const [edgeX, edgeY] = edge;
		const teachers = week.allClasses[m].l[edgeX][edgeY].Options;
		teachers.forEach((t) => {
			if (t === teacher) return;
			const newNode: callNodeType = {
				teacher: t,
				pos: edge,
				m,
				week,
				callTo: "nothing",
				parent: vertex,
				pivots: [...vertex.pivots],
			};
			if (preStrictConflicts(newNode)) return;
			const s = util.situation(t, edge, m, week);
			if (s.action === "shift" && s.r === -1) {
				// push to solutions
				if (newNode.pivots.length !== 0) {
					takeOneOffTheStack(newNode, queue);
				} else {
					solutions.push(backtrack(newNode));
				}
			} else if (s.action === "cycle" && s.r === -1) {
				newNode.callTo = "pull";
				queue.enqueue(newNode);
			} else if (s.action === "cycle" && s.r !== -1) {
				localQueue.enqueue({
					...newNode,
					callTo: "pivotTo",
					pivotArgs: {
						next_m: s.r,
						AfterReChainNode: {
							...newNode,
							callTo: "pull",
							parent: undefined,
						},
						beforeReChainNode: vertex,
					},
				});
			} else if (s.action === "shift" && s.r !== -1) {
				localQueue.enqueue({
					...newNode,
					callTo: "pivotTo",
					pivotArgs: {
						next_m: s.r,
						beforeReChainNode: vertex,
						AfterReChainNode: newNode,
					},
				});
			}
		});
	});
	const q_lenAfter = queue.length();
	if (q_lenAfter - q_lenBefore < 3) {
		while (localQueue.notEmpty()) {
			// queue.enqueue(localQueue.front())
			localQueue.callFront(push, pull, pivotTo);
			localQueue.dequeue();
		}
	}
}
/**
 * push Assumes that this step has r===-1
 * @param vertex
 * @returns
 */
function push(vertex: callNodeType, queue: argumentsQueue) {
	const { pos, m, action, week, teacher } = vertex;
	const solutions = week.activateList;
	const pivots = [...vertex.pivots];
	const S = util.situation(teacher, pos, m, week);
	const oldTeacher = S.currTeacher;
	if (vertex.teacher === oldTeacher) return;
	const cyclingActionSatisfied = (aboutToBeSquashed: TeacherId) => {
		if (action === "cycle" && vertex.cycleClosingParentName === undefined) {
			throw {
				...vertex,
				message:
					"push is a cycle and the vertex.cycleClosingParentName is undefined!",
			};
		} else {
			return (
				action === "cycle" &&
				vertex.cycleClosingParentName === aboutToBeSquashed
			);
		}
	};
	const localQueue = new argumentsQueue();
	const q_lenBefore = queue.length();
	const madePivots: number = pivots.length;
	if (!conflicts(vertex)) {
		if (
			((action === "shift" && S.currTeacher === TeacherType_nullValue) ||
				cyclingActionSatisfied(S.currTeacher)) &&
			!conflicts(vertex)
		) {
			if (vertex.pivots.length === 0) {
				solutions.push(backtrack(vertex));
			} else {
				takeOneOffTheStack(vertex, queue);
			}
		} else {
			if (oldTeacher === TeacherType_nullValue) return;
			const edges: PosType[] = week.availables[oldTeacher].filter(
				(edge: PosType) => {
					let tmp: callNodeType | null = vertex;
					while (tmp !== null) {
						if (equals(tmp.pos, edge)) return false;
						if (tmp.parent !== undefined) tmp = tmp.parent;
						// eslint-disable-next-line no-throw-literal
						else throw { ...tmp, message: "Parent is undefined!!" };
					}
					return true;
				}
			); // used position filtered out
			edges.forEach((p): void => {
				const newSituation = util.situation(oldTeacher, p, m, week);
				const newNode: callNodeType = {
					teacher: oldTeacher,
					pos: p,
					m,
					pivots,
					week,
					parent: vertex,
					callTo: "nothing",
					cycleClosingParentName: vertex.cycleClosingParentName,
					action,
				};
				if (
					((action === "shift" &&
						newSituation.currTeacher === TeacherType_nullValue) ||
						cyclingActionSatisfied(newSituation.currTeacher)) &&
					newSituation.r === -1 &&
					!conflicts(newNode)
				) {
					if (newNode.pivots.length === 0) {
						solutions.push(backtrack(newNode));
					} else {
						takeOneOffTheStack(newNode, queue);
					}
				} else {
					if (newSituation.r === m) {
						// this condition should be equivilant to currentTeacher===oldTeacher
					} else if (newSituation.r === -1) {
						// this means that it's possible for the old teacher to be put in this pos
						// but we still have to find a place to put the (current teacher at pos1) in.
						queue.enqueue({
							...newNode,
							callTo: "push",
						});
					} else {
						localQueue.enqueue({
							...newNode,
							callTo: "pivotTo",
							pivotArgs: {
								next_m: newSituation.r,
								beforeReChainNode: vertex,
								AfterReChainNode: {
									//<- push calls check if the called for is it self a solution
									...newNode,
									callTo: "push",
									parent: undefined,
								},
							},
						});
					}
				}
			});
		}
	}
	const q_lenAfter = queue.length();
	if (q_lenAfter - q_lenBefore < 3 && madePivots < 3) {
		while (localQueue.notEmpty()) {
			// queue.enqueue(localQueue.front())
			localQueue.callFront(push, pull, pivotTo);
			localQueue.dequeue();
		}
	}
}
const delegate = (
	teacher: TeacherId,
	pos: PosType,
	m: number,
	week: IWEEK_GLOBAL_Object,
	justOne: boolean = false
) => {
	const situationInt = util.situationInt;
	const S = util.situation(teacher, pos, m, week);
	const queue = new argumentsQueue();
	/**
	 * {teacher,pos,m,week,parent:null,callTo:'nothing',pivots:[]}
	 */
	const rootVertix: callNodeType = {
		teacher,
		pos,
		m,
		week,
		parent: null,
		callTo: "nothing",
		pivots: [],
	};
	const sit = situationInt(S);
	console.log(
		"" +
			JSON.stringify(pos) +
			" # " +
			week.allClasses[m].Name +
			" # " +
			teacher +
			" -> " +
			sit
	);
	switch (sit) {
		case 1: // t==='' & r===-1 & a ==='shift'
			week.Swapping = false;
			putHimAt(week, m, teacher, pos, "put");
			break;
		case 2: // t==='' & r!==-1 & a ==='shift'
			// Pivot
			queue.enqueue({
				...rootVertix,
				pivotArgs: { next_m: S.r, beforeReChainNode: rootVertix },
				callTo: "pivotTo",
			});
			break;
		case 3: // t==='' & r===-1 & a ==='cycle'
			// pull(teacher,pos,m,week,[])
			queue.enqueue({ ...rootVertix, callTo: "pull" });
			break;
		case 4: // t==='' & r!==-1 & a ==='cycle'
			queue.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						parent: undefined,
						callTo: "pull",
					},
					beforeReChainNode: null,
				},
			});
			break;
		case 5: // t!=='' & r===-1 & a ==='shift'
			// push(teacher, pos, m, week, [], S.action );
			queue.enqueue({ ...rootVertix, callTo: "push", action: S.action });
			break;
		case 6: // t!=='' & r!==-1 & a ==='shift'
			queue.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						callTo: "push",
						action: S.action,
					},
					beforeReChainNode: null,
				},
			});
			break;
		case 7: // t!=='' & r===-1 & a ==='cycle'
			queue.enqueue({
				...rootVertix,
				callTo: "push",
				action: S.action,
				cycleClosingParentName: rootVertix.teacher,
			});
			break;
		case 8: // t!=='' & r!==-1 & a ==='cycle'
			queue.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						callTo: "push",
						parent: undefined,
						cycleClosingParentName: rootVertix.teacher,
						action: S.action,
					},
					beforeReChainNode: null,
				},
			});
			break;
	}
	while (queue.notEmpty() && !enoughSolutions(week, justOne)) {
		queue.callFront(push, pull, pivotTo);
		queue.dequeue();
	}
	queue.unlock();
	queue.eraseAll();
};

export const someHowPutHimAt = (
	m: number,
	teacher: TeacherId,
	pos: PosType,
	week: IWEEK_GLOBAL_Object,
	freeze: boolean = true,
	iterativeSolutionposter?: (changes: TranspositionInstruction[]) => void,
	justOne: boolean = false
): void => {
	/*
	* discription*
	for each teacher available here in the original list in this cell
	for each pos in the shared postihions
	if the other teacher is in a pos in the shared one's just do a simple switch or promt for choice
	this should be enough?!
	?!
	*/
	//short hands
	week.Swapping = true;
	// week.HandyAny.beforeAction = [];
	// for (let i = 0; i < week.allClasses.length; i++) {
	// 	let acc = 0;
	// 	// Object.keys(week.allClasses[i].teachers).forEach(
	// 	// 	(teacher)=>{
	// 	// 	  acc = acc + week.allClasses[i].teachers[teacher].remPeriods;
	// 	// 	}
	// 	//   );
	// 	loopOverClass((u, v) => {
	// 		if (week.allClasses[i].l[u][v].currentTeacher === "") acc += 1;
	// 	});
	// 	week.HandyAny.beforeAction.push(acc);
	// }
	// week.HandyAny.test = () => {
	// 	if (week.HandyAny.beforeAction.length !== 0) {
	// 		console.log(week.HandyAny.beforeAction);
	// 	} else {
	// 		console.log("nothing");
	// 	}
	// 	week.HandyAny.beforeAction = [];
	// 	for (let i = 0; i < week.allClasses.length; i++) {
	// 		let acc = 0;
	// 		// Object.keys(week.allClasses[i].teachers).forEach(
	// 		// 	(teacher)=>{
	// 		// 	  acc = acc + week.allClasses[i].teachers[teacher].remPeriods;
	// 		// 	}
	// 		//   );
	// 		loopOverClass((u, v) => {
	// 			if (week.allClasses[i].l[u][v].currentTeacher === "") acc += 1;
	// 		});
	// 		week.HandyAny.beforeAction.push(acc);
	// 	}
	// 	console.log("became");
	// 	console.log(week.HandyAny.beforeAction);
	// };
	//   console.time('delegate')
	delegate(teacher, pos, m, week, justOne);
	//   console.timeEnd('delegate')
	// if (week.activateList.length > 0) {
	// 	const ms: number[] = [];
	// 	week.activateList[week.currentSolutionNumber].forEach((step) => {
	// 		let in_ms = false;
	// 		for (let i = 0; i < ms.length; i++) {
	// 			if (ms[i] === step.m) {
	// 				in_ms = true;
	// 				break;
	// 			}
	// 		}
	// 		if (!in_ms) {
	// 			ms.push(step.m);
	// 		}
	// 	});
	// 	week.HandyAny.validate = (week: IWEEK_GLOBAL_Object) => {
	// 		ms.forEach((m) => {
	// 			let dict: any = {};
	// 			const Class = week.allClasses[m];
	// 			loopOverClass((i, j) => {
	// 				const t = Class.l[i][j].currentTeacher;
	// 				if (dict[t] === undefined) {
	// 					dict[t] = 1;
	// 				} else {
	// 					dict[t] += 1;
	// 				}
	// 			});
	// 			Object.keys(dict).forEach((key) => {
	// 				if (key !== "" && dict[key] > Class.teachers[key].Periods) {
	// 					console.log(`m : ${m} and the teacher is ${key}`);
	// 					// eslint-disable-next-line no-throw-literal
	// 					throw "shit";
	// 				}
	// 			});
	// 			console.log("allz good validated!!");
	// 		});
	// 		loopOverClass((i: number, j: number) => {
	// 			for (let mi = 0; mi < week.allClasses.length; mi++) {
	// 				let dict: any = {};
	// 				if (dict[week.allClasses[mi].l[i][j].currentTeacher] !== undefined) {
	// 					console.log(
	// 						`${
	// 							week.allClasses[mi].l[i][j].currentTeacher
	// 						} is at two places at once ${mi} and ${
	// 							dict[week.allClasses[mi].l[i][j].currentTeacher]
	// 						}`
	// 					);
	// 					throw "damit";
	// 				} else {
	// 					dict[week.allClasses[mi].l[i][j].currentTeacher] = mi;
	// 				}
	// 			}
	// 		});
	// 	};
	// 	week.HandyAny.runTests = () => {
	// 		console.log(
	// 			week.activateList[week.currentSolutionNumber].map((item) =>
	// 				JSON.stringify(item)
	// 			)
	// 		);
	// 		week.HandyAny.test();
	// 		week.HandyAny.validate(week);
	// 	};
	// }
	if (!freeze) {
		Done(m, week, iterativeSolutionposter)({});
	}

	week.forceUpdate && week.forceUpdate();
};
export const Done = (
	m: number,
	week: IWEEK_GLOBAL_Object,
	iterativeSolutionposter?: (changes: TranspositionInstruction[]) => void
) => {
	return (e: any) => {
		const sol = week.activateList[week.currentSolutionNumber];
		if (sol === undefined) {
			week.Swapping = false;
			week.activateList = [];
			week.currentSolutionNumber = 0;
			week.forceUpdate && week.forceUpdate();
			return;
		}
		iterativeSolutionposter && iterativeSolutionposter(sol);
		for (let i = 0; i < sol.length; i++) {
			putHimAt(week, sol[i].m, sol[i].teacher, sol[i].pos, "remove");
		}
		for (let i = 0; i < sol.length; i++) {
			putHimAt(week, sol[i].m, sol[i].teacher, sol[i].pos, "put");
		}

		week.Swapping = false;
		week.activateList = [];
		week.currentSolutionNumber = 0;
		week.forceUpdate && week.forceUpdate();
	};
};

/*
<sc<script></script><script>alert('hi');</sc<script></script><script>
<<ss >script>alert('hi');<<ss >/script>
*/
